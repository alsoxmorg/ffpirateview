/*this is the original farbfeld file I modified.*/

#include <arpa/inet.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bzlib.h>
#include <glib/gi18n.h>
#include <glib/gstdio.h>
#include <libgimp/gimp.h>

/*#include "config.h"*/

#define LOAD_PROC "file_1fpirate_load"
#define SAVE_PROC "file_1fpirate_save"
#define extensions "1f,1ff"
#define    MAGIC "1fpirate"
#define OLDMAGIC "1bfarbfe"


static void query(void);
static void run(const gchar *name, gint nparams, const GimpParam *param,
                gint *nreturn_vals, GimpParam **return_vals);

GimpPlugInInfo PLUG_IN_INFO = {
  NULL,  /* init_procedure */
  NULL,  /* quit_procedure */
  query, /* query_procedure */
  run,   /* run_procedure */
};

MAIN()

  static void query(void) {
  static const GimpParamDef load_args[] = {
    {GIMP_PDB_INT32, "run_mode", "Interactive, non-interactive"},
    {GIMP_PDB_STRING, "filename", "The name of the file to load"},
    {GIMP_PDB_STRING, "raw_filename", "The name of the file to load"},
  };

  static const GimpParamDef save_args[] = {
    {GIMP_PDB_INT32, "run-mode", "Interactive, non-interactive"},
    {GIMP_PDB_IMAGE, "image", "Input image"},
    {GIMP_PDB_DRAWABLE, "drawable", "Drawable to save"},
    {GIMP_PDB_STRING, "filename", "The name of the file to save"},
    {GIMP_PDB_STRING, "raw-filename", "The name of the file to save"}};

  static const GimpParamDef load_return_vals[] = {
    {GIMP_PDB_IMAGE, "image", "Output image"},
  };

  gimp_install_procedure(LOAD_PROC,
			 "Loads 1fpirate images",
			 "Loads 1fpirate images.",
			 "Ian D. Scott",
			 "Copyright Ian D. Scott",
			 "2016",
			 "1fpirate image",
			 NULL,
			 GIMP_PLUGIN,
			 G_N_ELEMENTS(load_args),
			 G_N_ELEMENTS(load_return_vals),
			 load_args,
			 load_return_vals);

  gimp_register_file_handler_mime(LOAD_PROC, "image/1fpirate");
  gimp_register_magic_load_handler(
				   LOAD_PROC, extensions, "", "0,string,1fpirate");//, MAGIC);
  //LOAD_PROC, extensions, "", "0,string,farbfeld");
  gimp_install_procedure(SAVE_PROC,
			 "Saves 1fpirate images",
			 "Saves 1fpirate images.",
			 "Ian D. Scott",
			 "Copyright Ian D. Scott",
			 "2016",
			 "1fpirate image",
			 "RGB",
			 GIMP_PLUGIN,
			 G_N_ELEMENTS(save_args),
			 0,
			 save_args,
			 NULL);

  gimp_register_file_handler_mime(SAVE_PROC, "image/1fpirate");
  gimp_register_save_handler(SAVE_PROC, extensions, "");
}


static gint32 load_image(const gchar *filename) {
  FILE *fp = fopen(filename, "rb");
  if (!fp) return -1;

  char magic[8];
  fread(magic, 1, 8, fp);
  if (memcmp(magic, MAGIC, 8) != 0) {
    fclose(fp);
    return -1;
  }

  uint32_t width, height;
  fread(&width, 4, 1, fp);
  fread(&height, 4, 1, fp);
  width = ntohl(width);
  height = ntohl(height);

  gint32 image = gimp_image_new(width, height, GIMP_RGB);
  gint32 layer = gimp_layer_new(image, "1fpirate layer", width, height,
                                GIMP_RGB_IMAGE, 100, GIMP_NORMAL_MODE);
  gimp_image_insert_layer(image, layer, -1, 0);

  GimpDrawable *drawable = gimp_drawable_get(layer);
  GimpPixelRgn region;
  gimp_pixel_rgn_init(&region, drawable, 0, 0, width, height, TRUE, FALSE);

  guchar *row = g_new(guchar, width * 3);
  int row_bytes = (width + 7) / 8;

  for (uint32_t y = 0; y < height; y++) {
    fread(row, 1, row_bytes, fp);
    guchar *line = g_new(guchar, width * 3);
    for (uint32_t x = 0; x < width; x++) {
      int byte_index = x / 8;
      int bit_index = 7 - (x % 8);
      int bit = (row[byte_index] >> bit_index) & 1;
      guchar val = bit ? 0 : 255;
      line[x * 3 + 0] = val;
      line[x * 3 + 1] = val;
      line[x * 3 + 2] = val;
    }
    gimp_pixel_rgn_set_row(&region, line, 0, y, width);
    g_free(line);
  }

  g_free(row);
  gimp_drawable_flush(drawable);
  gimp_drawable_detach(drawable);
  fclose(fp);
  return image;
} /*load image*/

static gboolean save_image(const gchar *filename, uint16_t width, uint16_t height, GimpDrawable *drawable) {
  FILE *fp = fopen(filename, "wb");
  if (!fp) return FALSE;
  //uint16_t rgba[4], height, width, i, j, k, bpp;
  fwrite(MAGIC, 1, 8, fp);
  uint32_t w = htonl(width);
  uint32_t h = htonl(height);
  fwrite(&w, 4, 1, fp);
  fwrite(&h, 4, 1, fp);

  //gint32 drawable_ID = gimp_image_get_active_drawable(image_ID);
  //GimpDrawable *drawable = gimp_drawable_get(drawable_ID);
  GimpPixelRgn region;
  gimp_pixel_rgn_init(&region, drawable, 0, 0, width, height, FALSE, FALSE);

  guchar *src = g_new(guchar, width * height * 2);
  gimp_pixel_rgn_get_rect(&region, src, 0, 0, width, height);

  for (int y = 0; y < height; y++) {
    for (int xb = 0; xb < (width + 7) / 8; xb++) {
      uint8_t byte = 0;
      for (int bit = 0; bit < 8; bit++) {
        int x = xb * 8 + bit;
        if (x >= width) break;
        int v = src[(y * width + x) * 2];
        if (v < 128) byte |= (1 << (7 - bit));
      }
      fwrite(&byte, 1, 1, fp);
    }
  }
  g_free(src);
  gimp_drawable_detach(drawable);
  fclose(fp);
  return TRUE;
} /*save image*/


static void run(const gchar *name, gint nparams, const GimpParam *param,
                gint *nreturn_vals, GimpParam **return_vals) {
  static GimpParam values[2];
  char *filename, *ext;
  FILE *file;
  uint8_t hdr[strlen("1fpirate") + 2 * sizeof(uint32_t)];
  uint16_t rgba[4], height, width, i, j, k, bpp;
  guchar *buf;
  gint32 image, layer;
  GimpDrawable *drawable;
  GimpImageType image_type;
  GimpPixelRgn pixel_region;

  *return_vals = values;

  if (strcmp(name, LOAD_PROC) == 0) {
    filename = param[1].data.d_string;
    image = load_image(filename);
  } else if (strcmp(name, SAVE_PROC) == 0) {
    /*image = param[1].data.d_int32;
    drawable = gimp_drawable_get(param[2].data.d_int32);
    filename = param[3].data.d_string;

    image_type = gimp_drawable_type(drawable->drawable_id);
    if ((image_type != GIMP_RGBA_IMAGE) && (image_type != GIMP_RGB_IMAGE)) {
      *nreturn_vals = 2;
      values[0].type = GIMP_PDB_STATUS;
      values[0].data.d_status = GIMP_PDB_EXECUTION_ERROR;
      values[1].type = GIMP_PDB_STRING;
      values[1].data.d_string =
	"Image must be RGB/RGBA for 1fpirate export.";
	return;*/
    save_image(filename, width, height, drawable);
    /*
  width = drawable->width;
  height = drawable->height;
  gimp_pixel_rgn_init(
		      &pixel_region, drawable, 0, 0, width, height, FALSE, FALSE);
  
  file = g_fopen(filename, "wb");
  ext = strrchr(filename, '.');
  
  memcpy(hdr, "1fpirate", strlen("1fpirate"));
  *((uint32_t *)(hdr + 8)) = htonl(width);
  *((uint32_t *)(hdr + 12)) = htonl(height);
  fwrite(hdr, sizeof(hdr), 1, file);
  
  bpp = (image_type == GIMP_RGB_IMAGE) ? 3 : 4;
  buf = malloc(height * width * bpp);
  gimp_pixel_rgn_get_rect(&pixel_region, buf, 0, 0, width, height);
  
  for (i = 0; i < height; i++) {
    for (j = 0; j < width; j++) {
      for (k = 0; k < bpp; k++)
	rgba[k] = htons(buf[i * width * bpp + j * bpp + k] * 257);
      rgba[3] = (bpp < 4) ? 255 : rgba[3];
      fwrite(rgba, sizeof(uint16_t), 4, file);
    }
  }
  
  free(buf);
  fclose(file);
  gimp_drawable_detach(drawable);
  
  *nreturn_vals = 1;
  values[0].type = GIMP_PDB_STATUS;
  values[0].data.d_status = GIMP_PDB_SUCCESS;*/
  
  } else {
    *nreturn_vals = 1;
    values[0].type = GIMP_PDB_STATUS;
    values[0].data.d_status = GIMP_PDB_CALLING_ERROR;
  }
}
