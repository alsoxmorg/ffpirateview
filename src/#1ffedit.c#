
#include <SDL2/SDL.h>
//#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>

#ifdef WITHFARBFELD
#include "SDL_Farbfeld.h"
#endif

#define    MAGIC "1fpirate"
#define OLDMAGIC "1bfarbfe"
#define  FFMAGIC "farbfeld"
#define MODE_FF 1
#define MODE_1F 0


#define DEFAULT_WIDTH 600
#define DEFAULT_HEIGHT 800
#define INITIAL_WINDOW_WIDTH 800
#define INITIAL_WINDOW_HEIGHT 600


#define ZOOM_STEP 0.1f
#define MIN_ZOOM 0.1f
#define MAX_ZOOM 10.0f

int brush_size = 1;
int is_fullscreen = 0;
uint8_t *bitmap = NULL;
int width = 0, height = 0, row_bytes = 0;
int image_mode = MODE_1F; /*MODE_1F, MODE_FF*/
SDL_Texture *texture;
SDL_Renderer *renderer;

float zoom = 1.0f;
int offset_x = 0;
int offset_y = 0;

/*int x, y;
Uint32 buttons = SDL_GetMouseState(&x, &y);*/


void update_texture(SDL_Texture *texture) {
  if(image_mode == MODE_1F) {
    uint32_t *pixels = malloc(width * height * sizeof(uint32_t));
    for (int y = 0; y < height; y++) {
      for (int x = 0; x < width; x++) {
	int byte_index = y * row_bytes + (x / 8);
	int bit_index = 7 - (x % 8);
	int bit = (bitmap[byte_index] >> bit_index) & 1;
	pixels[y * width + x] = bit ? 0x00000000 : 0xFFFFFFFF;
      }
    }
    
    SDL_UpdateTexture(texture, NULL, pixels, width * sizeof(uint32_t));
    free(pixels);
  }
  else if(image_mode == MODE_FF) {
    SDL_RenderClear(renderer);
    //SDL_Rect dstRect = { panX, panY, 0, 0 };
    SDL_RenderCopy(renderer, texture, NULL, NULL); //&dstRect);
    SDL_RenderPresent(renderer);
    //SDL_UpdateTexture(texture, NULL, pixels, width * sizeof(uint32_t));
    //free(pixels);
  }
} /*update_texture*/

void save_1f(const char *filename) {
  FILE *f = fopen(filename, "wb");
  if (!f) {
    perror("Save failed");
    return;
  }
  fwrite(MAGIC, 1, 8, f);
  uint32_t w_be = htonl(width);
  uint32_t h_be = htonl(height);
  fwrite(&w_be, 4, 1, f);
  fwrite(&h_be, 4, 1, f);
  fwrite(bitmap, 1, row_bytes * height, f);
  fclose(f);
  printf("Saved to %s\n", filename);
} /*save_1f*/

void save_ff(const char *filename) {
  FILE *f = fopen(filename, "wb");
  if (!f) {
    perror("Save failed");
    return;
  }
  fwrite(FFMAGIC, 1, 8, f);
  uint32_t w_be = htonl(width);
  uint32_t h_be = htonl(height);
  fwrite(&w_be, 4, 1, f);
  fwrite(&h_be, 4, 1, f);
  /*write pixel data*/
  fclose(f);
} /*save_ff - save as farbfeld*/


void set_pixel(int x, int y, int value) {
  if (x < 0 || x >= width || y < 0 || y >= height) return;
  int byte_index = y * row_bytes + (x / 8);
  int bit_index = 7 - (x % 8);
  if (value)
    bitmap[byte_index+1] |= (1 << bit_index);
  else
    bitmap[byte_index+1] &= ~(1 << bit_index);
}

void set_pixels_wsize(int x, int y, int value) {
  if (x < 0 || x >= width || y < 0 || y >= height) return;
  for(int iy = 0; iy < brush_size; iy++) {
    for(int ix = 0; ix < brush_size; ix++) {  // ← fixed here
      set_pixel(x + ix, y + iy, value);
    }
  }
}

void set_pixelsff_wsize(int x, int y, int r, int g, int b) {
  /*or farbfeld mode*/
}

int get_pixel(int x, int y) {
  if (x < 0 || x >= width || y < 0 || y >= height) return 0;
  int byte_index = y * row_bytes + (x / 8);
  int bit_index = 7 - (x % 8);
  return (bitmap[byte_index] >> bit_index) & 1;
}

void flip_horizontal() {
  for (int y = 0; y < height; y++) {
    for (int x = 0; x < width / 2; x++) {
      int tmp = get_pixel(x, y);
      set_pixel(x, y, get_pixel(width - 1 - x, y));
      set_pixel(width - 1 - x, y, tmp);
    }
  }
}

void flip_vertical() {
  for (int y = 0; y < height / 2; y++) {
    for (int x = 0; x < width; x++) {
      int tmp = get_pixel(x, y);
      set_pixel(x, y, get_pixel(x, height - 1 - y));
      set_pixel(x, height - 1 - y, tmp);
    }
  }
} /*flip_vertical*/

void rotate_90() {
  int new_w = height;
  int new_h = width;
  int new_row = (new_w + 7) / 8;
  uint8_t *new_bmp = calloc(new_row * new_h, 1);

  for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
      int val = get_pixel(x, y);
      int nx = y;
      int ny = width - 1 - x;
      int idx = ny * new_row + (nx / 8);
      int bidx = 7 - (nx % 8);
      if (val) new_bmp[idx] |= (1 << bidx);
    }
  }
  free(bitmap);
  bitmap = new_bmp;
  width = new_w;
  height = new_h;
  row_bytes = new_row;

  SDL_DestroyTexture(texture);
  texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888,
			      SDL_TEXTUREACCESS_STREAMING, width, height);
  update_texture(texture);
} /* rotate 90 */


int load_1f(const char *filename) {
  FILE *f = fopen(filename, "rb");
  if (!f) return 0;
  char magic[9] = {0};
  fread(magic, 1, 8, f);  /*read magic*/
  uint32_t w_be, h_be;
  fread(&w_be, 4, 1, f);  /*read width*/
  fread(&h_be, 4, 1, f);  /*read height*/
  width = ntohl(w_be);    /*make it uint32_t*/
  height = ntohl(h_be);
  row_bytes = (width + 7) / 8;
  bitmap = malloc(row_bytes * height);
  fread(bitmap, 1, row_bytes * height, f);
  fclose(f);
  return 1;
} /*load1f?*/

int
load_pirate(const char *filename)
{ /* load a 1fpirate, or a farbfeld*/
  FILE *f = fopen(filename, "rb");
  if (!f) return 0;
  char magic[9] = {0};
  fread(magic, 1, 8, f);
  if (memcmp(magic, MAGIC, 8) == 0) /*1fpirate*/
    {
      image_mode = MODE_1F; /*MODE_1F, MODE_FF*/
      fclose(f);
      load_1f(filename);
      return 0;
    } /*we checked the magic for 1fpirate*/
  else if(memcmp(magic, FFMAGIC, 8) == 0) /*farbfeld*/
    {
      image_mode = MODE_FF; /*MODE_1F, MODE_FF*/
      fclose(f); /*close file*/
#ifdef WITHFARBFELD
      SDL_Surface *s = SDL_LoadFarbfeldSurface(filename);
      /*SDL_Texture *
	SDL_CreateTextureFromSurface(
	SDL_Renderer * renderer, SDL_Surface * surface);*/
      texture = SDL_CreateTextureFromSurface(renderer, s);
#endif
      return 0;
    } /*we checked the magic for farbfeld*/
  else /*invalid magic*/
    {
      printf("(%s) : error invalid magic.\n", magic);
      fclose(f);  /*image_mode = MODE_1F; MODE_1F, MODE_FF*/
      return 1;
    }
}

void blank_canvas() {
  width = DEFAULT_WIDTH;
  height = DEFAULT_HEIGHT;
  row_bytes = (width + 7) / 8;
  bitmap = calloc(row_bytes * height, 1);
  /* starts as white (0) */
}
void blank_ffcanvas() {  /* blank canvas for farbfeld*/
  int ff_width = DEFAULT_WIDTH;
  int ff_height = DEFAULT_HEIGHT;
  //int ff_pixels = calloc(ff_width * ff_height * 8, 1);
  uint8_t *ff_pixels = calloc(ff_width * ff_height * 8, 1);
  /* ^ 8 bytes per pixel: 4 channels × 2 bytes each */

  /* Fill with white (max = 0xFFFF = 65535) */
  for (uint32_t i = 0; i < ff_width * ff_height; ++i) {
    uint16_t *px = (uint16_t *)(ff_pixels + i * 8);
    px[0] = htons(0xFFFF); /* R*/
    px[1] = htons(0xFFFF); /* G*/
    px[2] = htons(0xFFFF); /* B*/
    px[3] = htons(0xFFFF); /* A*/
  }
} /*blank_ffcanvas*/


int main(int argc, char *argv[]) {
  const char *input = argc >= 2 ? argv[1] : NULL;
  const char *outfile = argc >= 3 ? argv[2] : "output.1ff";

  if (input && !load_1f(input)) {
    fprintf(stderr, "Failed to load %s\n", input);
    return 1;
  }

  if (!input)
    blank_canvas();
  SDL_Init(SDL_INIT_VIDEO);
  /*SDL_Window *window = SDL_CreateWindow("1ffedit",
    SDL_WINDOWPOS_CENTERED,
    SDL_WINDOW_ALLOW_HIGHDPI, width, height, 0);*/
  SDL_Window *window =
    SDL_CreateWindow(
		     "1ffedit",
		     0,
		     0,
		     DEFAULT_WIDTH, DEFAULT_HEIGHT,
		     SDL_WINDOW_SHOWN |
		     SDL_WINDOW_RESIZABLE |
		     SDL_WINDOW_MAXIMIZED
		     );
  renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
  texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888,
			      SDL_TEXTUREACCESS_STREAMING, width, height);
  //if(image_mode == MODE_1F) {
    update_texture(texture); /*lets check this.*/
    //}
    //if(image_mode == MODE_FF) {
    //update_fftexture(texture);
    //}
  int quit = 0;
  SDL_Event e;
  //float zoom = 1.0f;
  int panX = 0, panY = 0;
  int dragging = 0;

  int left_down = 0, right_down = 0;

  while (!quit) { /*main loop*/
    while (SDL_PollEvent(&e)) {
      if (e.type == SDL_QUIT)
	quit = 1;
      else if (e.type == SDL_KEYDOWN) {
	SDL_Keycode key = e.key.keysym.sym;
	if (key == SDLK_q || key == SDLK_ESCAPE) quit = 1;
	else if (key == SDLK_s) save_1f(outfile);
	else if (key == SDLK_r) rotate_90();
	else if (key == SDLK_h) flip_horizontal();
	else if (key == SDLK_v) flip_vertical();
	else if (key == SDLK_f) {
	  is_fullscreen = !is_fullscreen;
	  if (is_fullscreen) {
	    SDL_SetWindowFullscreen(window, SDL_WINDOW_FULLSCREEN_DESKTOP);
	  } else {
	    //SDL_SetWindowFullscreen(window, 0);
	    SDL_SetWindowFullscreen(window, 0);
	    SDL_SetWindowSize(window, INITIAL_WINDOW_WIDTH, INITIAL_WINDOW_HEIGHT);
	    SDL_SetWindowPosition(window, INITIAL_WINDOW_WIDTH, INITIAL_WINDOW_HEIGHT);
	    //#define INITIAL_WINDOW_WIDTH 800
	    //#define INITIAL_WINDOW_HEIGHT 600
	  }
	}
	else if (key == SDLK_1) {	  brush_size = 1;
	}
	else if	(key == SDLK_2)	{	  brush_size = 2+1;
	}
	else if	(key == SDLK_3)	{	  brush_size = 3+2;
	}
	else if	(key == SDLK_4)	{	  brush_size = 4+4;
	}
	else if (key == SDLK_KP_PLUS || key == SDLK_EQUALS)
	  {
	    zoom += ZOOM_STEP;
	    if (zoom > MAX_ZOOM) zoom = MAX_ZOOM;
	    //SDL_RenderSetScale(renderer, zoom, zoom);
	  }
	else if(key ==  SDLK_MINUS || key == SDLK_KP_MINUS)
	  {
	    zoom -= ZOOM_STEP;
	    if (zoom < MIN_ZOOM) zoom = MIN_ZOOM;
	    //SDL_RenderSetScale(renderer, zoom, zoom);
	  }
	update_texture(texture);
      }
      else if (e.type == SDL_MOUSEBUTTONDOWN) {
	if (e.button.button == SDL_BUTTON_LEFT) left_down = 1;
	if (e.button.button == SDL_BUTTON_RIGHT) right_down = 1;
      }
      else if (e.type == SDL_MOUSEBUTTONUP) {
	if (e.button.button == SDL_BUTTON_LEFT) left_down = 0;
	if (e.button.button == SDL_BUTTON_RIGHT) right_down = 0;
      }
      else if (e.type == SDL_MOUSEMOTION) {
	int win_x, win_y;
	SDL_GetMouseState(&win_x, &win_y);

	// get actual window size
	int win_w, win_h;
	SDL_GetWindowSize(window, &win_w, &win_h);

	// now convert to image coordinates
	int img_x = (win_x * width) / win_w;
	int img_y = (win_y * height) / win_h;

	//int win_w, win_h;
	int draw_w, draw_h;
	//SDL_GetWindowSize(window, &win_w, &win_h);
	SDL_GL_GetDrawableSize(window, &draw_w, &draw_h);
	//SDL_GetRendererOutputSize(renderer, &win_w, &win_h);
	// or SDL_GetRendererOutputSize if using renderer

	float scale_x = (float)draw_w / win_w;
	float scale_y = (float)draw_h / win_h;

	//int x = e.motion.x * scale_x;
	//int y = e.motion.y * scale_y;

	int x = e.motion.x * scale_x;
	int y = e.motion.y * scale_y;
	if (left_down) {
	  set_pixels_wsize(img_x, img_y, 1);
	  update_texture(texture);
	} else if (right_down) {
	  set_pixels_wsize(img_x, img_y, 0);
	  update_texture(texture);
	}
      }
    } /*end main loop*/

    SDL_RenderClear(renderer);
    //SDL_RenderSetScale(renderer, zoom, zoom);
    SDL_Rect dest = {
    .x = offset_x,
    .y = offset_y,
    .w = (int)(width * zoom),
    .h = (int)(height * zoom)
    };
    SDL_RenderCopy(renderer, texture, NULL, &dest); /*render the texture*/
    int mx, my;
    SDL_GetMouseState(&mx, &my);

    // Create a small rectangle centered on the mouse position
    SDL_Rect cursor_rect = { mx - 2, my - 2, 5, 5 };

    // Set draw color to red
    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
    SDL_RenderFillRect(renderer, &cursor_rect);
    SDL_RenderPresent(renderer);
  }

  SDL_DestroyTexture(texture);
  SDL_DestroyRenderer(renderer);
  SDL_DestroyWindow(window);
  SDL_Quit();
  free(bitmap);
  return 0;
}
